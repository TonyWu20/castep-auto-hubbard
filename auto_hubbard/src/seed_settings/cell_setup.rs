use std::marker::PhantomData;

use castep_cell_data::{
    cell::{
        bz_sampling_kpoints::KpointsList,
        constraints::{CellConstraints, FixCOM, IonicConstraints},
        external_fields::ExternalEfield,
        lattice_param::LatticeCart,
        positions::PositionsFrac,
        species::{
            AtomHubbardU, HubbardAlpha, HubbardU, QuantizationAxis, SpeciesLcaoStates, SpeciesMass,
            SpeciesPot,
        },
    },
    ToCellFileDerive,
};
use serde::{Deserialize, Serialize};

use super::{BeforePerturb, Init, JobType, Perturbed, Stage};

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, ToCellFileDerive)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub struct CellFile {
    lattice_cart: LatticeCart,
    positions_frac: PositionsFrac,
    kpoints_list: KpointsList,
    cell_constraints: CellConstraints,
    fix_com: FixCOM,
    ionic_constraints: IonicConstraints,
    external_efield: ExternalEfield,
    species_mass: SpeciesMass,
    species_pot: SpeciesPot,
    species_lcao_states: SpeciesLcaoStates,
    hubbard_u: HubbardU,
    hubbard_alpha: Option<HubbardAlpha>,
    quantization_axis: QuantizationAxis,
}

#[derive(Debug, Clone, PartialEq)]
pub struct HubbardUCell<T: Stage> {
    pub cell: CellFile,
    stage: PhantomData<T>,
}

impl HubbardUCell<Init> {
    pub fn from_cell_file(cell_file: CellFile) -> Self {
        Self {
            cell: cell_file,
            stage: PhantomData,
        }
    }
    pub fn cell_before(&self, u_value: f64, alpha_value: f64) -> HubbardUCell<BeforePerturb> {
        // Determine the u and alpha values based on job types
        let mut new_cell = self.cell.clone();
        // Set hubbard u
        // Currently, modify all presented u values to the provided value, regardless of orbitals
        // Since `HUBBARD_U` block is guaranteed to exist in our provided `.cell` files,
        new_cell
            .hubbard_u
            .atom_u_values
            .iter_mut()
            .for_each(|atom_hubbard_u| {
                atom_hubbard_u
                    .orbitals
                    .iter_mut()
                    .for_each(|orbital| orbital.set_u_value(u_value));
            });
        // Set hubbard alpha
        // Currently, modify all alpha value
        // Since `HUBBARD_ALPHA` block is not generated by default,
        match new_cell.hubbard_alpha.as_mut() {
            // Modify the mut
            Some(hub_alpha) => {
                *hub_alpha = update_hubbard_alpha_values(hub_alpha, alpha_value);
            }
            None => {
                // copy settings from `HubbardU`
                // to inherit the specified orbitals and species
                let HubbardU {
                    unit,
                    atom_u_values,
                } = new_cell.hubbard_u.clone();
                let atom_u_values = atom_u_values
                    .into_iter()
                    .map(|mut atom| {
                        atom.orbitals
                            .iter_mut()
                            .for_each(|orbital| orbital.set_u_value(alpha_value));
                        atom
                    })
                    .collect::<Vec<AtomHubbardU>>();
                new_cell.hubbard_alpha = Some(HubbardAlpha {
                    unit,
                    atom_u_values,
                })
            }
        };
        HubbardUCell {
            cell: new_cell,
            stage: PhantomData,
        }
    }
}

/// Update hubbard alpha value
fn update_hubbard_alpha_values(alpha: &HubbardAlpha, new_alpha_value: f64) -> HubbardAlpha {
    let atom_u_values = alpha
        .atom_u_values
        .iter()
        .map(|atom_hubbard_u| {
            let orbitals = atom_hubbard_u
                .orbitals
                .iter()
                .map(|orbital| {
                    let mut new_orbital = orbital.clone();
                    new_orbital.set_u_value(new_alpha_value);
                    new_orbital
                })
                .collect();
            AtomHubbardU {
                species: atom_hubbard_u.species.clone(),
                orbitals,
                ion_number: atom_hubbard_u.ion_number,
            }
        })
        .collect();
    HubbardAlpha {
        unit: alpha.unit,
        atom_u_values,
    }
}

impl HubbardUCell<BeforePerturb> {
    pub fn update_alpha(&self, new_alpha_value: f64) -> HubbardUCell<Perturbed> {
        HubbardUCell {
            cell: CellFile {
                hubbard_alpha: self
                    .cell
                    .hubbard_alpha
                    .as_ref()
                    .map(|hub_alpha| update_hubbard_alpha_values(hub_alpha, new_alpha_value)),
                ..self.cell.clone()
            },
            stage: PhantomData,
        }
    }
}

#[cfg(test)]
mod test {
    use std::{fs::read_to_string, path::Path};

    use castep_cell_data::from_str;

    use crate::seed_settings::{cell_setup::HubbardUCell, CellFile};

    #[test]
    fn hubbard_init() {
        let cwd = env!("CARGO_MANIFEST_DIR");
        let cell_path = Path::new(cwd)
            .parent()
            .unwrap()
            .join("sh/test/GDY_111_Fe_U.cell");
        let alpha_increment = 0.05;
        read_to_string(cell_path)
            .as_ref()
            .map(|input| {
                from_str::<CellFile>(input)
                    .map(HubbardUCell::from_cell_file)
                    .map(|hub_u_cell| hub_u_cell.cell_before(1e-7, 5.0))
                    .map(|hubbard_u_before| {
                        (1..5).for_each(|perturb_step| {
                            let perturbed_cell = hubbard_u_before
                                .update_alpha(perturb_step as f64 * alpha_increment);
                            dbg!(perturbed_cell.cell.hubbard_u);
                            dbg!(perturbed_cell.cell.hubbard_alpha);
                        });
                    })
                    .unwrap()
            })
            .unwrap();
    }
}
