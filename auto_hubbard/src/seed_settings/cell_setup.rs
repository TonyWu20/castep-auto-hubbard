use std::marker::PhantomData;

use castep_cell_data::{
    cell::{
        bz_sampling_kpoints::KpointsList,
        constraints::{CellConstraints, FixCOM, IonicConstraints},
        external_fields::ExternalEfield,
        lattice_param::LatticeCart,
        positions::PositionsFrac,
        species::{
            AtomHubbardU, HubbardAlpha, HubbardU, QuantizationAxis, SpeciesLcaoStates, SpeciesMass,
            SpeciesPot,
        },
    },
    ToCellFileDerive,
};
use serde::{Deserialize, Serialize};

use super::{BeforePerturb, Init, JobType, Perturbed, Stage};

#[derive(Debug, Clone, PartialEq, Deserialize, Serialize, ToCellFileDerive)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub struct CellFile {
    lattice_cart: LatticeCart,
    positions_frac: PositionsFrac,
    kpoints_list: KpointsList,
    cell_constraints: CellConstraints,
    fix_com: FixCOM,
    ionic_constraints: IonicConstraints,
    external_efield: ExternalEfield,
    species_mass: SpeciesMass,
    species_pot: SpeciesPot,
    species_lcao_states: SpeciesLcaoStates,
    hubbard_u: HubbardU,
    hubbard_alpha: Option<HubbardAlpha>,
    quantization_axis: QuantizationAxis,
}

#[derive(Debug, Clone, PartialEq)]
pub struct HubbardUCell<T: Stage> {
    pub cell: CellFile,
    stage: PhantomData<T>,
}

impl HubbardUCell<Init> {
    pub fn from_cell_file(cell_file: CellFile) -> Self {
        Self {
            cell: cell_file,
            stage: PhantomData,
        }
    }
    pub fn cell_before(
        &self,
        init_hubbard_u: f64,
        current_u: f64,
        job_type: JobType,
    ) -> HubbardUCell<BeforePerturb> {
        // Determine the u and alpha values based on job types
        let (u_value, alpha_value) = hubbard_init_value(init_hubbard_u, current_u, job_type);
        let mut new_cell = self.cell.clone();
        // Set hubbard u
        // Currently, modify all u value
        // Since `HUBBARD_U` block is guaranteed to exist in our provided `.cell` files,
        // use `entry` and `and_modify` method of `HashMap` to modify it inplace.
        new_cell
            .hubbard_u
            .atom_u_values
            .iter_mut()
            .for_each(|atom_hubbard_u| {
                atom_hubbard_u
                    .orbitals
                    .iter_mut()
                    .for_each(|orbital| orbital.set_u_value(u_value));
            });
        // Set hubbard alpha
        // Currently, modify all alpha value
        // Since `HUBBARD_ALPHA` block is not generated by default,
        // use `map_or_else` to handle the `Option<HubbardAlpha>`
        new_cell.hubbard_alpha = new_cell.hubbard_alpha.map_or_else(
            || {
                let cloned_atom_u_values = new_cell.hubbard_u.clone();
                let atom_u_values = cloned_atom_u_values
                    .atom_u_values
                    .into_iter()
                    .map(|mut atom| {
                        atom.orbitals
                            .iter_mut()
                            .for_each(|orbital| orbital.set_u_value(alpha_value));
                        atom
                    })
                    .collect::<Vec<AtomHubbardU>>();
                Some(HubbardAlpha {
                    unit: cloned_atom_u_values.unit,
                    atom_u_values,
                })
            },
            |mut alpha| {
                alpha.atom_u_values.iter_mut().for_each(|atom_hubbard_u| {
                    atom_hubbard_u
                        .orbitals
                        .iter_mut()
                        .for_each(|orbital| orbital.set_u_value(alpha_value));
                });
                Some(alpha)
            },
        );
        HubbardUCell {
            cell: new_cell,
            stage: PhantomData,
        }
    }
}

/// Update hubbard alpha value by increment
fn update_hubbard_alpha_values(alpha: &HubbardAlpha, alpha_increment: f64) -> HubbardAlpha {
    let atom_u_values = alpha
        .atom_u_values
        .iter()
        .map(|atom_hubbard_u| {
            let orbitals = atom_hubbard_u
                .orbitals
                .iter()
                .map(|orbital| {
                    let mut new_orbital = orbital.clone();
                    let u_value = new_orbital.u_value();
                    new_orbital.set_u_value(u_value + alpha_increment);
                    new_orbital
                })
                .collect();
            AtomHubbardU {
                species: atom_hubbard_u.species.clone(),
                orbitals,
                ion_number: atom_hubbard_u.ion_number,
            }
        })
        .collect();
    HubbardAlpha {
        unit: alpha.unit,
        atom_u_values,
    }
}

impl HubbardUCell<BeforePerturb> {
    pub fn add_alpha(&self, alpha_increment: f64) -> HubbardUCell<Perturbed> {
        HubbardUCell {
            cell: CellFile {
                hubbard_alpha: self
                    .cell
                    .hubbard_alpha
                    .as_ref()
                    .map(|hub_alpha| update_hubbard_alpha_values(hub_alpha, alpha_increment)),
                ..self.cell.clone()
            },
            stage: PhantomData,
        }
    }
}

/// Compute the desired values for initial `HUBBARD_U` and `HUBBARD_ALPHA`
/// # Return
/// (hubbard_u, hubbard_alpha)
fn hubbard_init_value(init_hubbard_u: f64, current_u: f64, job_type: JobType) -> (f64, f64) {
    // Calculate current u_value to use
    let curr_u_value = init_hubbard_u + current_u;
    // Determine the u and alpha values based on job types
    match job_type {
        // For U jobs, `HUBBARD_U` section uses the incremented `i_u_value`,
        // while `HUBBARD_ALPHA` section keeps the initial u value intact
        JobType::U => (curr_u_value, init_hubbard_u),
        // For alpha jobs, `HUBBARD_U` section keeps the initial u value intact,
        // while `HUBBARD_ALPHA` section uses the incremented `i_u_value`
        JobType::Alpha => (init_hubbard_u, curr_u_value),
    }
}

#[cfg(test)]
mod test {
    use std::{fs::read_to_string, path::Path};

    use castep_cell_data::from_str;

    use crate::seed_settings::{cell_setup::HubbardUCell, CellFile, JobType};

    #[test]
    fn hubbard_init() {
        let cwd = env!("CARGO_MANIFEST_DIR");
        let cell_path = Path::new(cwd)
            .parent()
            .unwrap()
            .join("sh/test/GDY_111_Fe_U.cell");
        let alpha_increment = 0.05;
        read_to_string(cell_path)
            .as_ref()
            .map(|input| {
                from_str::<CellFile>(input)
                    .map(HubbardUCell::from_cell_file)
                    .map(|hub_u_cell| hub_u_cell.cell_before(1e-7, 5.0, JobType::Alpha))
                    .map(|hubbard_u_before| {
                        (1..5).for_each(|perturb_step| {
                            let perturbed_cell =
                                hubbard_u_before.add_alpha(perturb_step as f64 * alpha_increment);
                            dbg!(perturbed_cell.cell.hubbard_u);
                            dbg!(perturbed_cell.cell.hubbard_alpha);
                        });
                    })
                    .unwrap()
            })
            .unwrap();
    }
}
