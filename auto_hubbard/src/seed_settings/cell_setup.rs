use std::{fs::read_to_string, path::Path};

use castep_cell_data::{
    cell::{
        bz_sampling_kpoints::KpointsList,
        constraints::{CellConstraints, FixCOM, IonicConstraints},
        external_fields::ExternalEfield,
        lattice_param::LatticeCart,
        positions::PositionsFrac,
        species::{
            AtomHubbardU, HubbardAlpha, HubbardU, QuantizationAxis, SpeciesLcaoStates, SpeciesMass,
            SpeciesPot,
        },
    },
    from_str, to_string, ToCell, ToCellFile, ToCellFileDerive,
};
use serde::{Deserialize, Serialize};

use super::JobType;

#[derive(Debug, Clone, Deserialize, Serialize, ToCellFileDerive)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub struct HubbardUCellFile {
    lattice_cart: LatticeCart,
    positions_frac: PositionsFrac,
    kpoints_list: KpointsList,
    cell_constraints: CellConstraints,
    fix_com: FixCOM,
    ionic_constraints: IonicConstraints,
    external_efield: ExternalEfield,
    species_mass: SpeciesMass,
    species_pot: SpeciesPot,
    species_lcao_states: SpeciesLcaoStates,
    hubbard_u: HubbardU,
    hubbard_alpha: Option<HubbardAlpha>,
    quantization_axis: QuantizationAxis,
}

/// Compute the desired values for initial `HUBBARD_U` and `HUBBARD_ALPHA`
/// # Return
/// (hubbard_u, hubbard_alpha)
fn hubbard_init_value(init_hubbard_u: f64, u_step: i32, job_type: JobType) -> (f64, f64) {
    // Calculate current u_value to use
    let i_u_value = init_hubbard_u + u_step as f64;
    // Determine the u and alpha values based on job types
    match job_type {
        // For U jobs, `HUBBARD_U` section uses the incremented `i_u_value`,
        // while `HUBBARD_ALPHA` section keeps the initial u value intact
        JobType::U => (i_u_value, init_hubbard_u),
        // For alpha jobs, `HUBBARD_U` section keeps the initial u value intact,
        // while `HUBBARD_ALPHA` section uses the incremented `i_u_value`
        JobType::Alpha => (init_hubbard_u, i_u_value),
    }
}

/// Initialize hubbard U and Alpha value for each step
/// # Arguments
/// - init_hubbard_u: initial value of hubbard u, e.g.: 0.000000010000000
/// - u_step: increment value for this operation, i32, e.g.: 2
/// - job_type: `JobType::U` or `JobType::Alpha`, determine the values to be set in `HUBBARD_U`
///   and `HUBBARD_ALPHA` blocks in `.cell` files
/// - cell_file: Path to the template `.cell` file.
/// # Return
/// - Ok(String): modified `.cell` content in `String`
pub fn hubbard_init<P: AsRef<Path>>(
    init_hubbard_u: f64,
    u_step: i32,
    job_type: JobType,
    cell_file: P,
) -> Result<String, anyhow::Error> {
    // Determine the u and alpha values based on job types
    let (u_value, alpha_value) = hubbard_init_value(init_hubbard_u, u_step, job_type);
    // Read `.cell` to string
    let cell_content = read_to_string(cell_file.as_ref())?;
    // Parse string into `ParsedCellDoc`, a `HashMap<&str, CELLObject>` wrapper struct.
    let mut parsed_cell = from_str::<HubbardUCellFile>(&cell_content)?;
    // Set hubbard u
    // Currently, modify all u value
    // Since `HUBBARD_U` block is guaranteed to exist in our provided `.cell` files,
    // use `entry` and `and_modify` method of `HashMap` to modify it inplace.
    parsed_cell
        .hubbard_u
        .atom_u_values
        .iter_mut()
        .for_each(|atom_hubbard_u| {
            atom_hubbard_u
                .orbitals
                .iter_mut()
                .for_each(|orbital| orbital.set_u_value(u_value));
        });
    // Set hubbard alpha
    // Currently, modify all alpha value
    // Since `HUBBARD_ALPHA` block is not generated by default,
    parsed_cell.hubbard_alpha = parsed_cell.hubbard_alpha.map_or_else(
        || {
            let cloned_atom_u_values = parsed_cell.hubbard_u.clone();
            let atom_u_values = cloned_atom_u_values
                .atom_u_values
                .into_iter()
                .map(|mut atom| {
                    atom.orbitals
                        .iter_mut()
                        .for_each(|orbital| orbital.set_u_value(alpha_value));
                    atom
                })
                .collect::<Vec<AtomHubbardU>>();
            Some(HubbardAlpha {
                unit: cloned_atom_u_values.unit,
                atom_u_values,
            })
        },
        |mut alpha| {
            alpha.atom_u_values.iter_mut().for_each(|atom_hubbard_u| {
                atom_hubbard_u
                    .orbitals
                    .iter_mut()
                    .for_each(|orbital| orbital.set_u_value(alpha_value));
            });
            Some(alpha)
        },
    );
    // Return the ordered cell doc, which keeps the original look of the given `.cell`
    Ok(to_string(&parsed_cell.to_cell_file())?)
}

#[cfg(test)]
mod test {
    use std::path::Path;

    use crate::seed_settings::JobType;

    #[test]
    fn hubbard_init() {
        let cwd = env!("CARGO_MANIFEST_DIR");
        let cell_path = Path::new(cwd)
            .parent()
            .unwrap()
            .join("sh/test/GDY_111_Fe_U.cell");
        let u = super::hubbard_init(0.000000010000000, 2, JobType::U, &cell_path).unwrap();
        let alpha = super::hubbard_init(0.000000010000000, 2, JobType::Alpha, &cell_path).unwrap();
        println!("{u}");
        println!("{alpha}");
    }
}
